> Êú¨ÊñáÁî± [ÁÆÄÊÇ¶ SimpRead](http://ksria.com/simpread/) ËΩ¨Á†ÅÔºå ÂéüÊñáÂú∞ÂùÄ [www.figma.com](https://www.figma.com/blog/behind-the-scenes-international-keyboard-shortcuts/)

> Software Engineer Dorothy Chen explains the technical challenges and opportunities in making Figma ke......

I didn‚Äôt know much about keyboards going into this project. As a software engineer on Figma's Editor Usability team, my day-to-day typically focuses on the design editor experience. Turns out, keyboard shortcuts are a big part of that. These preset key combinations are essential for efficient, intuitive workflows and have a host of accessibility benefits‚Äîsuch as making it easier to access menus and functions. Yet Figma‚Äôs many shortcuts were originally designed based on US keyboards, which meant that they didn‚Äôt work for many other types of¬†keyboards.

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB10lEQVQ4jY2TvUscQRjG708KoiklBrWXgElrY5OosVBzxirIqSQY0IBopekCUfTQOzi9xiInROxCglZ+JCTree7szM7MzhVPeGdvll09Qop3l3n34TfPvh85YwyiKPpnkOZ/dTkpJSi01vcEWkdQSiEMQwghEl27kFJaXY4ecUKg0fgNz7uE512gXv8FIZgFk5iApGs2mxm3xhibo2+ksUClJM7Pv6F6sIGtzXfY/PwWpb0V/Pheg5TcuiSxg9DZOVNKJfnEoRABjr+W8X5xCK8mH2FyohuzbwZwsL8OxupQKr7dAVyZ7pYrjIESnDPUvmyjMPsEoy86MPL8AfJTj7G3uwL/1ssA0yVwdY2yDmPgUW0H84WnGB97iLGRTsxM96FcWoXvX2eA7Vzquw4FAY+KWJh7hpejXdblzHQ/yqU1+H7WoYM5V1LKpI4JMAwDnJxUsLw0jNf5XuSnejBXGES1+rFtDSmosxSqdc40RWuJn1enODz8hN3iBxR3lrFfWcfZ6bEdp3SX3cikh9203gnQJiMNzm/RaPyx88jYjb2IXKTn0I2Nq1/bsSGhMfEv0Hakz+muuo0JgsAGY8y+KZ9silstJxaCt4IAMcS5oRzn/F64y4j1F9K+wOlefL9bAAAAAElFTkSuQmCC)![](https://cdn.sanity.io/images/599r6htc/localized/326aaa9032074f53dbecedb68499132f9bd3cb5d-1600x1050.png?rect=1,0,1599,1050&w=670&h=440&q=75&fit=max&auto=format)

Our team began seeing a steady stream of shortcut-related bug reports as users encountered instructions in Figma like ‚Äúpress `‚åò + \` to toggle the UI‚Äù‚Äîdespite their keyboards not having a `\` (back slash) key‚Äîor barring folks from [cursor chat](https://help.figma.com/hc/en-us/articles/4403130802199-Use-cursor-chat-in-Figma-design) conversations because it was impossible for them to press `/` (forward slash) to initiate messages. Figma users are passionate about their workflows and, in turn, their keyboard shortcuts. We wanted to make sure that everyone, everywhere, could access the same keyboard efficiencies. We brought together a cross-functional team to begin working on making Figma shortcuts friendlier to international keyboards, a charter that would take us on a twisty journey through the¬†next¬†year.

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAyUlEQVQYlU2OyWrEMBAF/f/fljmE4EtiD4m8qFsb3mR7YNwvSCNCDsWDLii6ev+on7fbm9R1jaZpRCkFZkYIAcuyYNs2rOtaWArrfyRtjDHts/r8alNM2rZB13UyDkMOOudyNOG9h3MWwWkEN8A7k2/FyTzPOI5DzvOUynt/WWuFSIPGXmhMQcrBV8jBWgtrDbzp4Y2Csy9fkGmasO+7xBiviokezHyNQ4/+5y7d9x2dUtBa508TRAwmApMu0J9jZjHGwBhzEdHjFyZiKwuE+UlbAAAAAElFTkSuQmCC)![](https://cdn.sanity.io/images/599r6htc/localized/2e5afbd30c7c34ac7a0771d586ebce0711bce02b-1600x314.png?rect=0,1,1600,313&w=670&h=131&q=75&fit=max&auto=format)

### [A quick overview on keyboard shortcuts](#a-quick-overview-on-keyboard-shortcuts)

When you press any key, the browser sends Figma standard [`KeyboardEvents`](https://developer.mozilla.org/en-US/docs/Web/API/KeyboardEvent) with information about which key was pressed. Our first step after receiving a `KeyboardEvent` is to translate it into something that our editor can interpret. Separately, we specify possible keyboard shortcuts and the actions they trigger in a JSON file. These actions vary based on whether the shortcuts themselves are enabled or disabled, which depends on user and product state, aspects like preferences, which product they‚Äôre in, the operating system (OS), and more. Once we receive a user‚Äôs key press, we run it against that list of possible shortcuts. If there is a match, we execute the associated action (and if not, nothing happens). Et voila ‚ú® a frame is pasted, the UI is toggled, a cursor chat bubble¬†appears.

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABdElEQVQokWVSzU7CQBjsE/oSvoUn400vhhdQT5qIB40xRg/iwUSEEDGCCBYwAlu6/du29CdwGDOLrSYeJvv37Tc7M2ssFgsUiOMYURRpcF7gd+9/bfynLkkSGFEUwnEEZlMT8/kXfN9FGIb6EgsIrok0TZDnGbIsLUnyPMdyuUSWZfqO4XkSjacrnFX3ULs7xmRiQilVsrKIa9e1IcQIQgwRBBJKBZDSgmWNIYQJaU+glA/Dtqe4OK9gZ3sDR4dbGAzaZUO+jg2DIIBlTdDvt9DrNSDEp1YyHr+jXr/Efe0E7eca2MtwpMDtzQEq+5uonu5iOOz8yEu1PI4k8D0XrjuH580RRQphqDTJx6CFbucBo9ErqNbgM4fmC5rNa7x1H2HbM+0NfVr7lZV+cU7PCK5JxAxIwJGqDEoiGyWwOed8YRwzwXWKRShEYUfRkAgCNozWKTMhFkoptVck4KHneXqPYxGQ7/twHKf8BUUd93i+Wq3wDRvIVGjUrGcZAAAAAElFTkSuQmCC)![](https://cdn.sanity.io/images/599r6htc/localized/c4dcff5d53e73c94e42bbc80db2ef084f8bcf61f-1600x617.png?rect=0,1,1600,616&w=670&h=258&q=75&fit=max&auto=format)

### [Easy fix? Not so¬†fast](#easy-fix-not-so-fast)

At face value, it would seem that all we needed to do was add some new shortcut definitions to the JSON file. If a user has a Swedish keyboard, give them the mapping `Meta + √Ñ` for ‚ÄúBring forward‚Äù instead of `‚åò + ]`. If a user has a Korean keyboard, give them the mapping `‚Ç©` for "Toggle UI" instead of `‚åò + \`.

This is where the rabbit hole starts.¬†üêáüï≥

On a German keyboard, the shortcut for ‚ÄúDecrease text weight‚Äù is `Meta + Alt + √ü`. Seems straightforward enough, yet this particular keyboard shortcut did not work when plugged into our keyboard shortcuts JSON. It turned out that when we tried to normalize shortcuts by capitalizing them, we saw that `"√ü".toUpperCase()` becomes `SS`, causing unexpected behavior when transforming a single key character `√ü` into two `SS`. Most unintuitively, that means `"√ü".toUpperCase().toLowerCase()` does not give us `√ü`, the original character.

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAChElEQVQ4jXWTy08TURTG+x+ZiIoaNRD/BTcu3GjcGOgLLJUFiQoGAwoYEqJEeUhbIFJQQCmCPNy5NSxIKC2P3hlmOs/OANOZ9jP3FDVSnOTk5J773d9899wcX8ODcwgFLiEaqUNr9GZVPGqpR3P4KppCV/6riUbqEA7WgrN8/oYadHfdwceZPiwvjeDr4jAWU++wmBrC8tIoPs8PYPBNGK8HApib7aca30st/NaMYPZTP3p77iLQeAE+7m7sfRt2djZQKGhQlAMIwh4kicE0NYhihiCp1FsILA3bNiHLAlhuF3lZgG0bYGwLkxOdCAcvV4DjiQ6IYhZOsQjLsqCqKgzDgOMUoaoSvq9PYnUlDl2XwL/Dw0MoigrLsmmtaxJmpnsQDp0AE/F25HJbODo6IrFt25Q5UJYZ1lbHsfItBk0VCcB1pmnAsgooFotQFIbp5Mu/wPF4O1gujeNjhwSu61J4nod8XqgAV2LQtAOUSiVyn8/noesa6VVVOAVMtIOxNBzHIRA/xGGeV6oC8pqiKGCMUXZdl5xXOzwB/uuwGlgug1qiaRpM04TrelBPAys9TFNvuLhQKFA+q4flcpn2dF2nPjrOWT2kK28T0DBMekH+94pYxPraxJ9X5g55DyVJJqjnlcj5dPLklYP+ixgZasXm5g+I4i5yuW3s7W2BsQxkOYdsdgMLXwYxPzeAbOYnVEXA/n4amcwmZUURqJ6IP6Vp8fkbzuNZxy2MjbZh6kM3klMvyD7PPLj7V3330dtzD/HYE6pxXSW6kJzqRjz2GM87b8PfWAMfnz8O5Vfn8xppvo5oSz0izTdoHQrW0kjxCAVq6VoPm67RPp9xPh28zkeYz/IvoJY1Gmsq0scAAAAASUVORK5CYII=)![](https://cdn.sanity.io/images/599r6htc/localized/00e0f910c7a9b10c8490e920e0e538077198d6a8-1600x1044.png?w=670&h=437&q=75&fit=max&auto=format)

Beware! We worked around this by using the new uppercase eszett character, `·∫û`, which thankfully remains the same when upper-cased.

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACEUlEQVQokYWSP2/aUBTF/ZkiurWd0g8RiUrNxhw60Cyt0i4klaJkSAkDStV2adZ0g4WpUqhaoroSGPPHjrHBxhjbYDDmnuq+Uhpl6ZV+eu8N77xz3z2Sqsirmx9f6Zd8A0VRqNvtwjRNOI4Dz/MQBAHCIETg+5hMJgJ/zfpMvu9jNpvRcrkkaWgZpPdU0nod6LpOhmEIQcu00O/3xTp2HEwcF57twHNGmLhjeOMxxq4L13XJdV2EYUhJkpA0m00RBD6GwwEJAcsSCFHLwshxMPUDxNMI8SxCHM0F8yhiV5hOpwzN53OsVitIi8WC2Ha9XkelXKZKpQymWq3ipyyza/TZtXBrwrFtIcSXiYhXWu9FSazc62k4O3uH3d1neJreQTq9g0wmg+PjE1xcvEexWEShUMD5eQGXl5/RbCpYLpfgIiLcLXaIlqri5asDPHz8CKkHW0iltrC9/QS53D5OTk9x9PYI+Xweh4d5lEolyLKMOI43gnQHKfAn1Gmr9OHjJ+Re7NPeXhbZ7HMcvH6Dq6svaDQaUFWVEwCl1YKmaeCp/m2Z/tS/lo1eG025jvr3b3R9XUOtVgP/Z6PRhG3bWCxiJEmygVu9D//jpuXbXps6TZn0bgt945Z4shwDkTff38B5vH8WGQ1DiqKIH+PhkGTbduIMLRqYGvqGToPBAKPRSIiOOWv/wfM8TgmLUxiGq99G+c7bOo0fawAAAABJRU5ErkJggg==)![](https://cdn.sanity.io/images/599r6htc/localized/20548527d82322244bc1d2b5fc6ae1ffc568485f-1606x833.png?rect=1,0,1604,833&w=670&h=348&q=75&fit=max&auto=format)

What? A new capitalized letter? In 2017, the new capital eszett character was [officially adopted by the German spelling council](https://qz.com/1033265/germanys-century-long-debate-over-a-missing-letter-in-its-alphabet), though the character has existed in fonts before that. Coding languages have not entirely caught up yet,¬†it¬†seems.

### [Choosing keyboard layouts](#choosing-keyboard-layouts)

With an [overwhelming number](https://kbdlayout.info/) of possible keyboard layouts, we wanted to start by supporting shortcuts for keyboard layouts that our users most commonly use. Gathering this information was easier via the desktop app, where we are able to detect the OS keyboard setting. However, on browsers, the best we could do was make guesses based on heuristics involving the [experimental Keyboard API](https://developer.mozilla.org/en-US/docs/Web/API/Keyboard_API), which has its own limitations. Here‚Äôs how our heuristics work: This API tells us the character associated with each positional key code for the current user, which we then map to known keyboard layouts. For example, we might get data that the keyboard‚Äôs `Quote` code has the `√§` character, and, in combination with other such mappings, we can extrapolate that perhaps the user has a Swedish keyboard.

With keyboard detection logging in place, we saw over 2.5k distinct layouts used on Figma within 30 days! I didn't even know this many keyboard layouts existed, and it turns out that there have always been _thousands_ of keyboard layouts. Marcin introduced us to these century-old Remington Typewriter layouts for [Domestic](https://archive.org/details/remington-typewriter-layouts-1-300), [Swiss-Standard](https://archive.org/details/remington-typewriter-layouts-1501-1700), and [Swedish](https://archive.org/details/remington-typewriter-layouts-1100-1300). Put a pin in this detail, because the struggle of keyboard detection comes back¬†later.

Combining our detection data with forum feedback posts, we narrowed down our initial work to a (not so short) shortlist of standard keyboards: German, French AZERTY, Japanese, British, Swedish, Finnish, Danish, Norwegian, Italian, Spanish, Spanish LATAM, Chinese, Portuguese, and¬†Korean.

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABzUlEQVQokWWS6W7aQBSFef+3aRtQWGxjYxvbY48XMERKUuIlDGYpiDzAFzEgtVJ/zpl7P51zZnpfX1fO5z8cjweUatntWn0+n88cDnuUaui6T06nI6fTif2+Y7ttOBx2D+1I1yl2quV6vdBr24b1ek2aSlzXJAhsXl5WWksSgWOPCEOH5TKnKAqiyMdxRqQyoCyX5HmG79t4nsFm80qvaRoWiwVhOGcy6WPbQ4o8fQy6jMc/cd0JaRoTx4LZzGIy+UUUuWSZRIgQyxxiGk+8vb3cHLaUZUkUBRhGH3v6TFGkFEVOEPha8zyTLEuQMsHzbEyzjxAeaZoQxxHT6egBXNOr60o7vAFNY6CBeZaQZRlB4D2Axv/AyEPKGCEibHusNQ2sqo3u5h75SV9IKR7LDqPRD2azsY4npWQ2m94jhy4yEURRiGUNtfb6+gAuFsW9C+tZd5ilsX6kvw5N8jzVrn3fwTQH/0QWOI6BZQ14v3fYsFqV+tL3LMLAoSwLlsuFduq5JnHss16vdNdCBLqCPI/13s1MELjM5xZV9Zve5XJGqS038MfHO3X9wW6n2G63NE2ttbat6boOpRRNU1FV7yj1qbXb3C1lXW/0//0G0q9rmA+12bwAAAAASUVORK5CYII=)![](https://cdn.sanity.io/images/599r6htc/localized/30c360df9bb1cceca66bfbaa82c8b774b93d4636-1600x735.png?rect=1,0,1599,735&w=670&h=308&q=75&fit=max&auto=format)

### [Designing new shortcuts](#designing-new-shortcuts)

With keyboards identified, the next step was auditing which keyboard shortcuts were problematic, either due to missing keys, physical inaccessibility, or conflicts with other shortcuts. Almost all of these shortcuts involved symbol characters (as opposed to roman letters), which cut down the number of shortcuts to¬†investigate.

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACs0lEQVQ4jWWTeW8iRxTE/f2/SCJtlMPZRLHl2Fkcc84aWGYwi80MM8x9NMzBgMH4F3WzZmXlj1ZLr9X1ql7VO9vv92w2G+q6pihWBIFFGJjUdclut1P19XqNEDGuO0WIgN3ume12q97KsiCKHAJ/Rr0uOJPFNE0JwxDLeqR5d0679RtJ4pLnOUEQ4Ps+htHj5voHHsYtymKl/sg3x7Hodi9oNn8liuZHQCEykiTB82z6/RuGg2tEFrBaScYBURTx9KTT6fzBbDagLHOSRJKICAIXfXTHYPA3WepxJuUul0uyLMP3F3wZNhiNPrEUEUVREMexamaaY7TeBZb5haoqEEKoehj6GHpLkcgy/7tkycK2n2i1PtLpfDxJ9jyfxWLBaNThn5sfmTy01ayPkkMWizm97iXNu1+OkiVD2S1NM0XfMFrq02qVKEA5P9d1eZyO6PevcZyxYigVSfZRFDB56GHo/7IU4XuGjmPS617wWbsgS/2TKZ7nMjY0bhs/Mf3aUzOUgNJI17XRtCvarXPi2DkCxnGkmNj2jM/aFf3+FVkWvJOs6z1ub3/mcap9M0Wa6GFZM7rdSzptOabFG2CsmMhuun7HeNxktYy/SZZ1l8lkiNa7xJ4bSrJUJZvZtsmg32AgkyGC94Dz+f9zKJlLyYbePZnylkPZzLZN2q0/uW18IAyt77ERYkmaRsxmQ0xzSFEIlUMJqEJvPnB/f8V8rr8zJZSxMdoMhzcqu2fH9VpT1xXbba3Ofv+MXMk8l4CBYj+dDmk1z3l6vD+ZIo30vAWDwSc07S/SxJWAcicLylKwrlY8P294fX3l5eVFSZbs5JlM+jQaH/g66Zw2RZri2NbR5fbvxLH9BlhSVUvW61wxPBxeOBwOVFWlZMs7zwVx5JDnKdvtRtWl08e19dTMN5uK/wDngQCus3UTmAAAAABJRU5ErkJggg==)![](https://cdn.sanity.io/images/599r6htc/localized/f707da57eb4f6745cc27390ac5b55fd4eb2f1a6c-1600x1139.png?w=670&h=477&q=75&fit=max&auto=format)

As a graphic tool and a text editor that exists within the realm of a browser (which also exists within an operating system)‚ÄîFigma inherits all the shortcuts from each of these spaces, many of which are already in conflict with each other. Keeping a holistic view of where Figma fits within these various ecosystems is important when developing shortcuts that will impact a user‚Äôs workflow. For example, we want to maintain motor memory that users may already have from other tools, aligning our shortcuts to similar actions (say, copy, paste, zoom). At the same time, we need to avoid duplicate shortcut conflicts not only between existing Figma shortcuts, but also between shortcuts defined by the OS or other major desktop applications.

Additionally, there are many other considerations when adapting existing US QWERTY keyboard shortcuts to a swath of new keyboard layouts:

*   Physical comfort of keyboard shortcuts: Where are key combinations located on a keyboard, and are they comfortable to¬†reach?
*   Maintaining ‚Äúpair‚Äù logic where applicable: Actions like ‚Äúmove to front‚Äù and ‚Äúmove to back‚Äù should have keyboard shortcuts with keys physically next to¬†each¬†other.
*   Mac and Windows versions of all shortcuts: The `‚åò` key on Mac is usually used like the `Control` key on Windows, but there is still a `Control` key on Mac that is used for some shortcuts, adding edge cases and exceptions to this OS modifier key translation.

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkUlEQVQoka1Sy2rCUBTMB+tSQfsJomBBi13r2o1FFxHFB7jRLhQV1PpMzEuT+FxOmSMBa7tooYtJ7p0zmTP35CqHwwH/CcXzPBC73Q6bzQaLxQK2bQtHWJYlHGuu6wrnfuP3N971oDiOA8M0MZt9oFR6Q6FQwGAwENPt1kCv9458Po9KpQJd10G9fseXy2VomgbLtqUuhqZpYTQaI51+RjQaRaPZEENdN6CqVUQiEWQyGSyXSzhyEg3NVguJREICrNdrOM4OuqZDYXzfP2A+XyCVSiEUCqFer9+O7HqyDofDSCaTYsg5McB4NIaqquh2uzKK8/l8m6Hv+zidTjKL11wO8VgM7XYbx+NR0Ol08BSP4yWblSTU8lSr1QrD4VDe5K7XKy6XCxS60pRzqFarKBaLmEwm0pHgmlytVoNpmtKE6anv9/uYTqeypylrCh+MbBiGdKOQTdiRoJjDZp3r4Hrs93vhLMv6woshE1JAY+4ZnWDCoHPwAbXE4/0LeDnyb8VB7X7/+I38lL/gpyb3jT4Bzj0in/yKXQ0AAAAASUVORK5CYII=)![](https://cdn.sanity.io/images/599r6htc/localized/329a40ce3f0b48102c362d01fc13616e5a9316f5-1600x882.png?rect=0,1,1600,881&w=670&h=369&q=75&fit=max&auto=format)

### [Layout preferences, an¬†aside](#layout-preferences-an-aside)

One of our next product questions was how to store users‚Äô keyboard preferences. My initial intuition was that, like most preferences, keyboard layout preference should also be assigned per user. But keyboard preferences are not just a software artifact, they are indelibly tied to physical objects: keyboards themselves. And so, we had to consider the case where the same user might have multiple devices, perhaps one at work and one at home, with different keyboard layouts.

We decided to store keyboard layout preferences on device `localStorage`, so that different devices can have different default Figma keyboard layouts‚Äîwhile also writing user preferences to a database. If a user clears their browser cache (which includes `localStorage`), or logs in to a brand new device, we can still load their most recent preference from our backend. While this storage system was complex, we knew it would result in a better user experience.

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAACSUlEQVQokV2RTU8TURSG+wtMjAsxoUrQFGvvVKYpGgoUFEyhIwZEvikf7czt57TTUlpQUAINqIBQAiGoiBG0OzExIgnuXShrfguLe18zU+vCxZub++TcJ+fcY1ICBMNDVvR2W9DfV4Wg7ERaa0M6KSEWrkU4KCIadiBEb2LEZ0VvjwWD/VVQAoLBo2EHgoodukePSfbbIHkr4RDLUOcyI0LbsbW6he38Dp4+HkFCrUVCvYUQFeFtq4RYXQZ3w2WMDtuRTLigJWr/SgVQmcAUGLOh5e4VXK28ALtQhojyCHvbX1HYOcbCrIpkoh5a/DaoLKKp0YyKivOG1DcoIJ1qQDrlRiziBC0J9Q67Oq/hTpMZkteCca0D+aU5LOWmoan3IfsdiISciMdcGPbVoNVzHe2SFSFaj2zag5TmRjgkQpFJUajP7R+9gbERgqlJCXsf5lH4+AKTmYdo9VhQX1eOvh47ll8GUPj0HGuvVDyZHMJSbhYrC88wkZJAjT+0FYVUJlwJ2Hg4KPK1VcpPTo75719HfGZ6gIvVl7i5/ByXvITv7y3y09Of/Oj7e765muOFtz/4/ptDPp31cSrbDYfu0oWGXd/i/Fw3vhys4+BzHtnMAzQ1VsAhXkRXJ8F6XsXht9fYfTeDxbkINlc2sLG8hkyqA1QWjA0XO1QIozJhVBGYGq1h2Ylmls00s0jIyXxDVjbQX8X8o4RpiTo2lb3HxpNupkZdLBlvYcl4sc54LxMWVAgzBRVyRkuRi9FZif9/lmpKzOD/7sLZH+pOd6Gnr3WAAAAAAElFTkSuQmCC)![](https://cdn.sanity.io/images/599r6htc/localized/5bd2d6e9296b7077c36caaefe92d93dcbab9c2c8-1600x755.png?w=670&h=316&q=75&fit=max&auto=format)

### [‚ÄúDead keys‚Äù and other shortcut nightmares](#dead-keys-and-other-shortcut-nightmares)

To return to the challenge of remapping these shortcuts: On a French AZERTY keyboard, the shortcut for ‚ÄúUnindent text‚Äù is `Meta + ^`. To be extra explicit, if a user presses `Meta + ^`, we want their text to unindent, and not output a `^` character. Unfortunately, `^` is a [diacritic](https://en.wikipedia.org/wiki/Diacritic) key, meaning that it adds a glyph on top of another character. When `^` is pressed on an AZERTY keyboard, the browser tells us, ‚Äúthis is a [dead key](https://en.wikipedia.org/wiki/Dead_key)‚Äù* to indicate that we‚Äôre waiting to compose it with another key, and [throws us a bunch of other KeyboardEvents](https://developer.squareup.com/blog/understanding-composition-browser-events/) that we need to handle in order to prevent `^` from appearing.

But of course, browsers are inconsistent, and in particular, [Safari swaps the order](https://bugs.webkit.org/show_bug.cgi?id=165004) of `keydown` and `compositionstart` events for diacritic keys, leading us to emit the `^` character when we should be executing an¬†action.

So, whereas Chrome orders¬†events:

1.  keydown
2.  compositionstart
3.  compositionupdate
4.  input

Safari orders them:

1.  compositionstart
2.  compositionupdate
3.  input
4.  keydown

We rely on the keydown event to understand whether the shortcut is accepted or not, and based on that, will reject characters in the `input` event listener. On Safari, with these events out of order, that logic breaks. Practically, this means that our shortcut for unindenting doesn‚Äôt work¬†on¬†Safari.

*An aside from our resident keyboard expert Marcin: _‚ÄúDead keys‚Äù come from the world of typewriters, where a key would output an accent, but not advance the carriage‚Äîsince they didn‚Äôt move, they were ‚Äúdead.‚Äù The correct sequence of events was ‚Äúassembling‚Äù a letter by typing a dead key first to put the accent on the page, and then a regular letter on¬†top¬†of¬†it._

On all keyboards, ‚ÄúZoom reset‚Äù is `Shift + 0.` An innocuous shortcut, unless you extensively use the numpad on your keyboard. Pressing `Shift` in combination with a numpad key [overrides numlock](https://devblogs.microsoft.com/oldnewthing/20040906-00/?p=37953), and perhaps surprisingly, means ‚ÄúZoom reset‚Äù doesn‚Äôt work. Marcin [tweeted about this bug quirk](https://twitter.com/figma/status/1395445717783613443) in 2021, the result of decisions made by other designers/manufacturers decades ago‚Äîwhich is basically the story of keyboards in¬†a¬†nutshell.

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA00lEQVQYlWXM22qEMBSFYd//1WIoU8dD6WzPTrITY9MBawXJKrFDb3rx8cO6WElDFd7fchDdQtt2GIcBd6WhzQy2C7R1Z3lefntuC7RxUMad/fCPsO87ouTx6bEsDswclFKItGawseDzLB7PMGaG4SfrTtY6zMbBOx+29Qvf24bEe39Ya0Pf9yCiQESo6/qp+dPWDTqq0VODoesxjRPUeIcapqDHCZY5OOeOpKqqNcuyQ0oJIUQQQiBN039kJFK8SInXywX59Yo8z6MQWxTFUZbl+gNQ6SN71wEcXAAAAABJRU5ErkJggg==)![](https://cdn.sanity.io/images/599r6htc/localized/5b5602f063d377949b644ad7ab7dc845d29c6869-1600x352.png?rect=0,1,1600,351&w=670&h=147&q=75&fit=max&auto=format)

### [Shouting about shortcuts from the¬†rooftops](#shouting-about-shortcuts-from-the-rooftops)

Once we finished supporting all these new keyboard shortcuts for all these keyboard layouts, we were still barely halfway done. We needed to notify non-QWERTY users that they have more keyboard shortcut coverage now, without bothering QWERTY users for whom nothing changed. Additionally, if users change their physical or OS keyboard layout, we didn‚Äôt want to add confusion as to why there might now be a mismatch between their Figma keyboard shortcuts and what they see at their fingertips. The team drew up several flowcharts for handling such cases, where the path branches based on Figma desktop app versus browser, the user‚Äôs existing Figma keyboard layout preference (if any), and the user‚Äôs system keyboard layout.

Re-enter the uncertainty of user keyboard layout detection.

On the Figma Desktop app, we can see users‚Äô OS keyboard layout as their string names: `com.apple.keylayout.ABC` or `00004009` or `org.sil.ukelele.keyboardlayout.armenianphonetic.armenian-phonetic`. Given this information, it‚Äôs not immediately clear what Figma keyboard layout we should recommend to the user. We have to just live with the uncertainty, where obvious matches‚Äî`com.apple.keylayout.US` is a US QWERTY layout on Figma, [`0000040C`](https://learn.microsoft.com/en-us/windows-hardware/manufacture/desktop/windows-language-pack-default-values?view=windows-11) is a French AZERTY layout on Figma‚Äîcan be used to help guide users‚Äô Figma keyboard layout preference, but otherwise we fall back to doing nothing. (And even this has its pitfalls: In the middle of this project, Apple switched the name of some of its Japanese layouts, which broke our native internal mapping. Specifically, `com.apple.inputmethod.Kotoeri.Japanese` became `com.apple.inputmethod.Kotoeri.KanaTyping.Japanese.Katakana`. This caused us to switch to prefix-matching, which, while still imperfect, is better than exact string matching.)

On browsers, this decision tree gets even fuzzier because of the challenge in actually detecting what keyboard layout a user has. Not only do we get less coverage because the KeyboardLayout API is not available on all browsers, but bridging the gap between that data and an actual layout is an imperfect process. There are several layouts that we cannot detect at all via this method on¬†browsers.

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABgUlEQVQokX1S0W7kMAjM//9n1Ws3iWMbg40xU5Ftq72XIo1GIsCMIdtaC2aG4GkLQ4Md7g4H4GtC6YGe36FDsNxhd8+6eyzY1rPeHducE6qKqQaiiSMreKyXgQujEcqZ0JpgzgURRWsdYyi6KDobbH4P/FGZw9DqRCkTfYT6syDUOysodwgrdBjoElAiSOuoSVAOBtcBm4Yt7EtnCFUMZgh3SGPoGJjTMMaE8ATTRBfDkAk6CXwVCDHKceH82HHsCZk6tq4DKT+QzzdIO1BrQr52MFeQNGSuqNxQG4NYwCzoVKFSoaOjM6HVC2fO2Itgi/1RK+CWMKQi5xPp3FGpYM8H3o9/+Ew7zpxwlQwWhs2BtRTusetYj0GnoavdO3Qz87XMVdVLzn6l5ETk6Ur+8fj0/Tg8l3znhg6Pnt/A83Y33P33KIFQEek3wnkwEd/PjIvGTqP+7gn+/lVesYWY2XILp7fb5ZELD9OWDzXX+cy9xn8uX2KLb39hxaz1d80rvgCA+A5+ILpfMwAAAABJRU5ErkJggg==)![](https://cdn.sanity.io/images/599r6htc/localized/902986e3c5d298dfff06b3f477cf2b528eca3fff-1600x837.png?rect=0,1,1600,836&w=670&h=350&q=75&fit=max&auto=format)

To add even more complexity, it is a common pattern to regularly and frequently toggle between a roman character keyboard layout and a non-roman character layout at the OS level. For Japanese users, for example, it‚Äôs common to switch between Japanese and ABC layouts multiple times in a session, while using the same physical keyboard. It‚Äôs ok for your keyboard shortcuts to be in a different language than your words; not all keyboard layout changes necessitate changing your Figma keyboard layout settings.

Here‚Äôs a secret: We came very close to launching a version of international keyboard shortcut support with an option that would auto-update a user‚Äôs keyboard layout when a system keyboard change was detected. But all the aforementioned challenges around how immediate our keyboard detection technology could be made us pause and think about what we were actually trying to accomplish. In the end, we abandoned the idea. At best, it would alert people when they switch keyboard layouts, and at worst, cause unintended changes to their settings. We scratched several iterations of our onboarding and keyboard detection decision tree, aiming to be as minimally intrusive as¬†possible.

Our final design touch? Adding a visualization of keyboard layouts in the settings pane. There are tons of keyboard layouts (and customizable for those inclined), so it's not always easy to identify one by name alone. Our solution: Diagram all supported Figma keyboard layouts, thus giving people a way to visually that confirm their Figma keyboard matches their physical keyboard.

![](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsklEQVQYlW3QTWoDMQwF4LmHn2T9Ley5/wW6K8kJui3tpptA6raETuzgLIZSsvgQ4oEktAB4EZGTmX25e1PVRkQtpbQD0ESkzTwi/vt0928R+QDwtBDRq5n9RMTV3TdV3XLOd8y8m1kpZVvXdau1/vVbSunufiai5wXAexa9iOpg5k5E4xF3H6WUUWvdzX4Om3Vey8zHJQFv4HwB8Ugp9UcAdBHpEXHn7t3MdnOZmc1XHW6o+GwJpFPwdgAAAABJRU5ErkJggg==)![](https://cdn.sanity.io/images/599r6htc/localized/589a01930bf7d706a3ece3eef7df8b166c76e860-2275x461.png?rect=3,0,2271,461&w=670&h=136&q=75&fit=max&auto=format)

Alright, now let‚Äôs `Shift + -` (‚ÄúZoom out‚Äù): **In November, we shipped keyboard shortcut support for a set of non US QWERTY keyboards.** We emerged from the other side of the rabbit hole. That being said, this work is never done! We continue to add new shortcuts, refine existing ones, and add guardrails to prevent regressions. Our keyboard layout coverage is far from comprehensive, and we welcome your requests via [this Google form](https://docs.google.com/forms/d/e/1FAIpQLSd-Pb0Ib3jNa0wn7cV3NVjZcTKOfQoYRuv5TVja103ym-ShHQ/viewform).

_Much thanks to the entire team: Marcin Wichary (designer and resident keyboard expert), KC Oh (product manager), Rachel Miller (engineering manager), [Sula Yang](https://twitter.com/pseullah) (product marketing manager), and [Michael Feldstein](https://twitter.com/msfeldstein) (engineer)._